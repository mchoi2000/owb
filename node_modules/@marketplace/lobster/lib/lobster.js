"use strict";

var path = require("path"),
    gulp = require("gulp"),
    dateFormat = require("dateformat"),
    _ = require("lodash"),
    through2 = require("through2"),
    cheerio = require("cheerio"),
    rp = require("request-promise"),
    DTAT_COVERAGE_URL = "http://buoy.mybluemix.net/api/v1/coverage-doc",
    DEFAULT_COVERAGE_FILE_PATH = "coverage/lcov-report/index.html",
    coverageOptionsBase = {
        method: "POST",
        uri: "",
        body: {
        },
        headers: {
            "content-type": "application/json"
        }
    },
    SELECTOR_COVERAGE_STATS = ".header.high h2 > .metric:nth-child(-n+2)",
    SELECTOR_COVERAGE_STATS_ALTERNATE = ".fl.pad1y.space-right2:nth-child(-n+2)",
    REGEX_COVERAGE_STATS = /^([^%]+)(?:[^\(]+)\((\d+)(?:[^\d]+)(\d+)\)([^%]+)(?:[^\(]+)\((\d+)(?:[^\d]+)(\d+)\)$/,
    REGEX_COVERAGE_STATS_ALTERNATE = /^\s*([^%]+)%\s*Statement[^\d]*(\d+)\/(\d+)\s*([^%]+)%\s*Branches[^\d]*(\d+)\/(\d+)\s*$/;

function getCoverageStats (coverageFileContents) {
    let $ = cheerio.load(coverageFileContents),
        selectedText = $(SELECTOR_COVERAGE_STATS);

    if (selectedText.text()) {
        return selectedText.text().match(REGEX_COVERAGE_STATS);
    } else {
        selectedText = $(SELECTOR_COVERAGE_STATS_ALTERNATE);
        return selectedText.text().match(REGEX_COVERAGE_STATS_ALTERNATE);
    }
}

function postCoverageStats (opts, coverageOptions) {
    let logMessage = "Posting coverage info to " + coverageOptions.uri + "\n";

    return rp(coverageOptions)
        .then((body) => {
            logMessage += JSON.stringify(coverageOptions, null, 4)  + "\n";
            logMessage += body + "\n";

            return logMessage;
        })
        .catch((reason) => {
            logMessage += "Failed posting to coverage endpoint: " + reason + "\n";

            return logMessage;
        });
}

function sendIstanbulCoverageInfo (opts) {
    let coverageOptions = _.clone(coverageOptionsBase);

    return through2.obj(function (file, enc, callback) {
        let coverageStats = getCoverageStats(String(file.contents)),
            coverageStatObject = {
                "lineCoverage": coverageStats[1],
                "coveredLines": coverageStats[2],
                "totalLines": coverageStats[3],
                "branchCoverage": coverageStats[4],
                "coveredBranches": coverageStats[5],
                "totalBranches": coverageStats[6],
                "apiKey": opts.apiKey
            };

        coverageOptions.uri = opts.dtatCoverageService || DTAT_COVERAGE_URL;
        coverageOptions.body = JSON.stringify(coverageStatObject);
        coverageOptions.apiKey = opts.apiKey;

        postCoverageStats(opts, coverageOptions)
        .then((message) => {
            let fileHistory = file.history[0];

            file.history[0] = fileHistory.replace(new RegExp(path.basename(fileHistory) + "$"), dateFormat(new Date(), "'coverage-info-'yyyy-mm-dd-h-MM-ss'.log'"));
            file.contents = new Buffer(message);
            this.push(file);
            callback();
        });
    });
}

function getIstanbulDefaultPathStream () {
    return gulp.src(getIstanbulDefaultPath());
}

function getIstanbulDefaultPath () {
    return process.env.LOBSTER_DEFAULT_COVERAGE_FILE_PATH || DEFAULT_COVERAGE_FILE_PATH;
}

module.exports = {
    sendIstanbulCoverageInfo: sendIstanbulCoverageInfo,
    getIstanbulDefaultPathStream: getIstanbulDefaultPathStream,
    getIstanbulDefaultPath: getIstanbulDefaultPath
};
